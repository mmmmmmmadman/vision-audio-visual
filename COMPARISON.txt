================================================================================
DELAY IMPLEMENTATION COMPARISON
Original VCV Rack vs Python Extension
================================================================================

## 1. DelayProcessor Class Declaration
----------------------------------------

### VCV Rack (Alien4.cpp, lines 90-116):
```
struct DelayProcessor {
    static constexpr int DELAY_BUFFER_SIZE = 96000;
    float buffer[DELAY_BUFFER_SIZE];
    int writeIndex = 0;

    DelayProcessor() { reset(); }

    void reset() {
        for (int i = 0; i < DELAY_BUFFER_SIZE; i++) {
            buffer[i] = 0.0f;
        }
        writeIndex = 0;
    }

    float process(float input, float delayTime, float feedback, float sampleRate) {
        int delaySamples = (int)(delayTime * sampleRate);
        delaySamples = clamp(delaySamples, 1, DELAY_BUFFER_SIZE - 1);

        int readIndex = (writeIndex - delaySamples + DELAY_BUFFER_SIZE) % DELAY_BUFFER_SIZE;
        float delayedSignal = buffer[readIndex];

        buffer[writeIndex] = input + delayedSignal * feedback;
        writeIndex = (writeIndex + 1) % DELAY_BUFFER_SIZE;

        return delayedSignal;
    }
};
```

### Extension (alien4_extension.cpp, lines 125-155):
```
class DelayProcessor {
public:
    static constexpr int DELAY_BUFFER_SIZE = 96000;

    DelayProcessor() {
        buffer.resize(DELAY_BUFFER_SIZE, 0.0f);
        writeIndex = 0;
    }

    void reset() {
        std::fill(buffer.begin(), buffer.end(), 0.0f);
        writeIndex = 0;
    }

    float process(float input, float delayTime, float feedback, float sampleRate) {
        int delaySamples = static_cast<int>(delayTime * sampleRate);
        delaySamples = clamp(delaySamples, 1, DELAY_BUFFER_SIZE - 1);

        int readIndex = (writeIndex - delaySamples + DELAY_BUFFER_SIZE) % DELAY_BUFFER_SIZE;
        float delayedSignal = buffer[readIndex];

        buffer[writeIndex] = input + delayedSignal * feedback;
        writeIndex = (writeIndex + 1) % DELAY_BUFFER_SIZE;

        return delayedSignal;
    }

private:
    std::vector<float> buffer;
    int writeIndex;
};
```

DIFFERENCES:
- VCV uses float array, Extension uses std::vector (functionally identical)
- VCV uses C-style cast, Extension uses static_cast (better practice)
- Logic is IDENTICAL

## 2. Instance Declaration
--------------------------

### VCV Rack (Alien4.cpp, line 273-274):
```
DelayProcessor delayL, delayR;
```

### Extension (alien4_extension.cpp, line 896):
```
DelayProcessor delayL, delayR;
```

IDENTICAL ✓

## 3. Processing Calls
----------------------

### VCV Rack (Alien4.cpp, lines 813-814):
```
float delayedL = delayL.process(eqL, delayTimeL, delayFeedback, args.sampleRate);
float delayedR = delayR.process(eqR, delayTimeR, delayFeedback, args.sampleRate);
```

### Extension (alien4_extension.cpp, lines 831-834):
```
float delayedL = delayL.process(eqL, delayTimeL, delayFeedback, sampleRate);
float delayedR = delayR.process(eqR, delayTimeR, delayFeedback, sampleRate);
```

IDENTICAL ✓ (just args.sampleRate vs sampleRate naming)

## 4. Parameter Storage
-----------------------

### VCV Rack (Alien4.cpp):
```
float delayTimeL = params[DELAY_TIME_L_PARAM].getValue();
float delayTimeR = params[DELAY_TIME_R_PARAM].getValue();
```

### Extension (alien4_extension.cpp, lines 298-299):
```
delayTimeL = 0.25f;
delayTimeR = 0.25f;
// Set via set_delay_time(time_l, time_r) method
```

DIFFERENT: Extension uses methods instead of params (expected for Python binding)
BUT: Still stores separate L/R values ✓

================================================================================
CONCLUSION: 100% FUNCTIONALLY IDENTICAL
================================================================================

Both implementations:
1. Declare separate delayL and delayR instances ✓
2. Each instance has its own buffer ✓
3. Each instance has its own writeIndex ✓
4. Process with independent parameters ✓
5. Use identical algorithm ✓

The delay stereo independence is FULLY WORKING in both versions!
