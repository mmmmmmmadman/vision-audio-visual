# GPU Multiverse æ¸²æŸ“å™¨ä¿®å¾©èˆ‡å„ªåŒ– - 2025-11-04 23:18

## æ‘˜è¦

å®Œæˆ Qt OpenGL (Metal) GPU Multiverse æ¸²æŸ“å™¨çš„é—œéµä¿®å¾©ï¼Œè§£æ±ºé›»å£“æ­£è¦åŒ–å…¬å¼éŒ¯èª¤ã€region map æ”¯æ´ï¼Œä»¥åŠ blend mode åŠŸèƒ½å•é¡Œã€‚

## æ—¥æœŸèˆ‡æ™‚é–“

- é–‹å§‹æ™‚é–“: 2025-11-04 22:00
- å®Œæˆæ™‚é–“: 2025-11-04 23:18
- ç¸½è¨ˆç”¨æ™‚: ~1.5 å°æ™‚

## å•é¡ŒèƒŒæ™¯

ä½¿ç”¨è€…å›å ± GPU ç‰ˆæœ¬çš„ Multiverse æ¸²æŸ“å™¨è¦–è¦ºæ•ˆæœèˆ‡ CPU ç‰ˆæœ¬å®Œå…¨ä¸åŒï¼Œä¸”åœ¨å•Ÿç”¨ region map æ™‚ blend modes ç„¡æ³•æ­£å¸¸é‹ä½œã€‚

## ä¿®å¾©å…§å®¹

### 1. é›»å£“æ­£è¦åŒ–å…¬å¼ä¿®å¾©ï¼ˆCriticalï¼‰

**æª”æ¡ˆ**: `vav/visual/qt_opengl_renderer.py`

**å•é¡Œæ ¹æº** (line 152):
```glsl
// éŒ¯èª¤çš„å…¬å¼
float normalized = clamp(abs(waveValue) * 0.05 * intensities[ch], 0.0, 1.0);
```

**ä¿®å¾©å¾Œ** (line 152):
```glsl
// æ­£ç¢ºçš„å…¬å¼ï¼ŒåŒ¹é… Multiverse.cpp å’Œ Numba æ¸²æŸ“å™¨
float normalized = clamp((waveValue + 10.0) * 0.05 * intensities[ch], 0.0, 1.0);
```

**å½±éŸ¿**:
- ç§»é™¤éŒ¯èª¤çš„ `abs()` å‡½æ•¸ï¼Œä¿ç•™å®Œæ•´æ³¢å½¢è³‡è¨Š
- åŠ å…¥ `+ 10.0` åç§»ï¼Œæ­£ç¢ºå°‡ -10V~+10V è½‰æ›ç‚º 0~1 ç¯„åœ
- è¦–è¦ºè¼¸å‡ºç¾åœ¨èˆ‡ CPU ç‰ˆæœ¬ä¸€è‡´

**æ•¸å­¸åŸç†**:
```
Eurorack é›»å£“ç¯„åœ: -10V åˆ° +10V
åŠ ä¸Šåç§»: 0V åˆ° 20V
æ­£è¦åŒ–: (voltage + 10.0) * 0.05 = 0.0 åˆ° 1.0
å¥—ç”¨å¼·åº¦: normalized * intensity
```

### 2. Region Map å‚³éä¿®å¾©

**æª”æ¡ˆ**: `vav/core/controller.py`

**ä¿®å¾©å‰** (lines 504-507):
```python
# Only Numba renderer supports region_map parameter
if region_map is not None and NUMBA_AVAILABLE and isinstance(self.renderer, NumbaMultiverseRenderer):
    rendered_rgb = self.renderer.render(channels_data, region_map=region_map)
else:
    rendered_rgb = self.renderer.render(channels_data)
```

**ä¿®å¾©å¾Œ** (lines 502-507):
```python
# Both Numba and Qt OpenGL renderers support region_map parameter
if region_map is not None:
    rendered_rgb = self.renderer.render(channels_data, region_map=region_map)
else:
    rendered_rgb = self.renderer.render(channels_data)
```

**å½±éŸ¿**:
- Qt OpenGL æ¸²æŸ“å™¨ç¾åœ¨æ­£ç¢ºæ¥æ”¶ region map è³‡æ–™
- Region-based rendering åŠŸèƒ½å®Œå…¨é‹ä½œ

### 3. Region Map Y-Flip ä¿®å¾©

**æª”æ¡ˆ**: `vav/visual/qt_opengl_renderer.py`

**ä¿®å¾©** (lines 118-119):
```glsl
// Flip Y coordinate for region map (OpenGL texture coordinates)
float regionVal = texture(region_tex, vec2(v_texcoord.x, 1.0 - v_texcoord.y)).r;
```

**åŸå› **:
- OpenGL ç´‹ç†åº§æ¨™åŸé»åœ¨å·¦ä¸‹è§’
- æ”å½±æ©Ÿè¼¸å…¥çš„ region map åŸé»åœ¨å·¦ä¸Šè§’
- éœ€è¦ Y è»¸ç¿»è½‰ä»¥æ­£ç¢ºå°æ‡‰

### 4. æ—‹è½‰å‹•æ…‹ç¸®æ”¾å„ªåŒ–

**æª”æ¡ˆ**: `vav/visual/qt_opengl_renderer.py`

**å¯¦ä½œ** (lines 127-143):
```glsl
// Apply rotation with dynamic scaling (match CPU's rotate_image)
if (abs(angle) > 0.1) {
    // Calculate scale to fill canvas and avoid black borders
    float rad = radians(angle);
    float abs_cos = abs(cos(rad));
    float abs_sin = abs(sin(rad));
    // Assuming square texture (width == height)
    float scale_x = abs_cos + abs_sin;
    float scale_y = abs_sin + abs_cos;
    float scale = max(scale_x, scale_y);

    // Apply inverse rotation with scaling
    vec2 centered = (uv - 0.5) / scale;  // Scale before rotation
    centered = rotate(centered, angle);
    uv = centered + 0.5;

    // Skip only if truly out of bounds after scaling
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) continue;
}
```

**æ•ˆæœ**:
- æ—‹è½‰å¾Œè‡ªå‹•ç¸®æ”¾å¡«æ»¿ç•«å¸ƒ
- é¿å…é»‘é‚Šç”¢ç”Ÿ
- åŒ¹é… CPU ç‰ˆæœ¬çš„ `rotate_image()` è¡Œç‚º

### 5. Blend Mode å¯¦ä½œï¼ˆéƒ¨åˆ†é™åˆ¶ï¼‰

**æª”æ¡ˆ**: `vav/visual/qt_opengl_renderer.py`

**ç•¶å‰å¯¦ä½œ** (lines 173-189):
```glsl
// Apply region filtering: zero out if not in this channel's region
if (use_region_map > 0 && ch != currentRegion) {
    channelColor = vec4(0.0);
}

// Only blend non-zero colors
if (channelColor.a > 0.001) {
    if (firstChannel) {
        result = channelColor;
        firstChannel = false;
    } else {
        result = blendColors(result, channelColor, blend_mode);
    }
}
```

**åŠŸèƒ½ç‹€æ…‹**:
- âœ“ Blend modes åœ¨ region map é—œé–‰æ™‚å®Œå…¨é‹ä½œ
- âš ï¸ Blend modes åœ¨ region map å•Ÿç”¨æ™‚æ•ˆæœæœ‰é™

**å·²çŸ¥é™åˆ¶**:
- ç•¶ region map å•Ÿç”¨æ™‚ï¼Œæ¯å€‹åƒç´ åªæ¸²æŸ“ä¸€å€‹é€šé“
- å› ç‚ºåªæœ‰ä¸€å€‹é¡è‰²ï¼Œblend æ“ä½œæ²’æœ‰ç¬¬äºŒå€‹é¡è‰²å¯æ··åˆ
- é€™æ˜¯ GPU å–®æ¬¡æ¸²æŸ“æ¶æ§‹çš„å›ºæœ‰é™åˆ¶
- CPU ç‰ˆæœ¬ä½¿ç”¨å¤šæ¬¡æ¸²æŸ“ (multi-pass) é¿å…æ­¤å•é¡Œ

**æœªä¾†æ”¹é€²æ–¹å‘**:
- å¯¦ä½œå¤šæ¬¡æ¸²æŸ“æ¶æ§‹ (éœ€è¦é‡æ§‹æ•´å€‹æ¸²æŸ“æµç¨‹)
- æˆ–æ¥å—æ­¤é™åˆ¶ï¼Œå› ç‚º region map ä¸»è¦ç”¨æ–¼ç©ºé–“åˆ†é›¢è€Œéé¡è‰²æ··åˆ

## æŠ€è¡“ç´°ç¯€

### Blend Modes å¯¦ä½œ

å››ç¨®æ··åˆæ¨¡å¼åœ¨ `blendColors()` å‡½æ•¸ä¸­å¯¦ä½œï¼š

```glsl
vec4 blendColors(vec4 c1, vec4 c2, int mode) {
    if (mode == 0) {
        // Add
        return min(vec4(1.0), c1 + c2);
    } else if (mode == 1) {
        // Screen
        return vec4(1.0) - (vec4(1.0) - c1) * (vec4(1.0) - c2);
    } else if (mode == 2) {
        // Difference (RGB only, max alpha)
        vec3 diff_rgb = abs(c1.rgb - c2.rgb);
        float max_alpha = max(c1.a, c2.a);
        return vec4(diff_rgb, max_alpha);
    } else if (mode == 3) {
        // Color Dodge (RGB only, max alpha)
        vec3 dodge_rgb = c1.rgb / (vec4(1.0) - c2).rgb;
        float max_alpha = max(c1.a, c2.a);
        return vec4(dodge_rgb, max_alpha);
    }
    return c1;  // Fallback
}
```

### Curve å¯¦ä½œ

å½æ›²æ•ˆæœä½¿ç”¨ Y-based X-sampling offsetï¼š

```glsl
// Apply curve (Y-based X-sampling offset)
float x_sample = uv.x;
if (curve > 0.001) {
    float y_from_center = (uv.y - 0.5) * 2.0;
    float bend_shape = sin(uv.x * PI);
    float bend_amount = y_from_center * bend_shape * curve * 2.0;
    x_sample = fract(x_sample + bend_amount);
}
```

æ­¤å¯¦ä½œå·²å„ªæ–¼åŸå§‹ Multiverse.cppï¼ˆåŸç‰ˆç„¡ curve åŠŸèƒ½ï¼‰ã€‚

## é©—è­‰çµæœ

### ç³»çµ±åˆå§‹åŒ–è¼¸å‡º

```
âœ“ Qt OpenGL (Metal) Multiverse renderer: 1920x1080 (GPU accelerated)
[Qt OpenGL] Rendering frame 100 (thread: MainThread)
  Ch0: enabled=True, intensity=0.939, freq=93.8Hz, angle=0.0
  Ch1: enabled=True, intensity=0.939, freq=140.6Hz, angle=45.0
  Ch2: enabled=True, intensity=1.342, freq=0.0Hz, angle=90.0
  Ch3: enabled=True, intensity=0.939, freq=632.8Hz, angle=135.0
```

### åŠŸèƒ½ç¢ºèªæ¸…å–®

- [x] GPU åŠ é€Ÿå•Ÿç”¨ï¼ˆQt OpenGL with Metal backendï¼‰
- [x] é›»å£“æ­£è¦åŒ–å…¬å¼æ­£ç¢º
- [x] å››é€šé“åŒæ™‚æ¸²æŸ“
- [x] æ—‹è½‰å‹•æ…‹ç¸®æ”¾å¡«æ»¿ç•«å¸ƒ
- [x] Camera Y-flip æ­£ç¢º
- [x] Region map åŠŸèƒ½é‹ä½œ
- [x] Blend modesï¼ˆç„¡ region map æ™‚ï¼‰
- [âš ï¸] Blend modesï¼ˆæœ‰ region map æ™‚ - æ¶æ§‹é™åˆ¶ï¼‰

## æ•ˆèƒ½è³‡è¨Š

**GPU å¾Œç«¯**: Metal (Apple Silicon å„ªåŒ–)
**è§£æåº¦**: 1920x1080
**æ¸²æŸ“æ¨¡å¼**: Single-pass fragment shader
**åŸ·è¡Œç·’**: MainThread (Qt OpenGL context)

**æ¯å¹€ GPU Operations**:
- 1x æ¸…ç©º buffer
- 4x é€šé“æ¸²æŸ“ (å¦‚æœå…¨éƒ¨å•Ÿç”¨)
- 0-4x æ—‹è½‰è®Šæ› (ä¾ angle è¨­å®š)
- å…§éƒ¨ blend æ“ä½œ
- 1x äº®åº¦èª¿æ•´
- 1x Read back to CPU

## æª”æ¡ˆä¿®æ”¹è¨˜éŒ„

### ä¸»è¦ä¿®æ”¹

1. **vav/visual/qt_opengl_renderer.py**
   - Line 118-119: Region map Y-flip
   - Line 127-143: æ—‹è½‰å‹•æ…‹ç¸®æ”¾
   - Line 152: é›»å£“æ­£è¦åŒ–å…¬å¼ä¿®å¾©
   - Line 173-189: Region filtering èˆ‡ blend é‚è¼¯

2. **vav/core/controller.py**
   - Lines 502-507: Region map å‚³éè‡³ GPU æ¸²æŸ“å™¨

### ç›¸é—œæª”æ¡ˆï¼ˆåƒè€ƒç”¨ï¼‰

- `vav/visual/numba_renderer.py` - CPU æ¸²æŸ“å™¨åƒè€ƒå¯¦ä½œ
- `Multiverse.cpp` - åŸå§‹ VCV Rack æ¨¡çµ„å¯¦ä½œ

## èˆ‡ CPU ç‰ˆæœ¬çš„å°æ‡‰

| åŠŸèƒ½ | CPU (Numba) | GPU (OpenGL) | ç‹€æ…‹ |
|------|-------------|--------------|------|
| é›»å£“æ­£è¦åŒ– | `(v + 10) * 0.05 * i` | `(v + 10) * 0.05 * i` | âœ“ ä¸€è‡´ |
| æ—‹è½‰ç¸®æ”¾ | `rotate_image()` | Dynamic scaling | âœ“ ä¸€è‡´ |
| Curve | Y-based offset | Y-based offset | âœ“ ä¸€è‡´ |
| Blend Add | `blend_add()` | `blendColors(mode=0)` | âœ“ ä¸€è‡´ |
| Blend Screen | `blend_screen()` | `blendColors(mode=1)` | âœ“ ä¸€è‡´ |
| Blend Difference | `blend_difference()` | `blendColors(mode=2)` | âœ“ ä¸€è‡´ |
| Blend Dodge | `blend_color_dodge()` | `blendColors(mode=3)` | âœ“ ä¸€è‡´ |
| Region Map | Multi-pass layers | Single-pass filter | âš ï¸ éƒ¨åˆ† |

## å·²çŸ¥å•é¡Œèˆ‡é™åˆ¶

### 1. Blend Modes with Region Map

**å•é¡Œ**: ç•¶ region map å•Ÿç”¨æ™‚ï¼Œblend modes æ•ˆæœæœ‰é™ã€‚

**åŸå› **: GPU å–®æ¬¡æ¸²æŸ“æ¶æ§‹ä¸‹ï¼Œæ¯å€‹åƒç´ åªè™•ç†ä¸€å€‹é€šé“ï¼ˆregion å°æ‡‰çš„é€šé“ï¼‰ï¼Œæ²’æœ‰å¤šå€‹é¡è‰²å¯ä¾›æ··åˆã€‚

**è§£æ±ºæ–¹æ¡ˆ**:
- çŸ­æœŸ: æ¥å—æ­¤é™åˆ¶ï¼Œregion map ä¸»è¦ç”¨æ–¼ç©ºé–“åˆ†é›¢
- é•·æœŸ: å¯¦ä½œå¤šæ¬¡æ¸²æŸ“æ¶æ§‹ï¼ˆéœ€é‡æ§‹ï¼Œåƒè€ƒ `GPU_REFACTOR_PLAN_20251104.md`ï¼‰

### 2. Shader Validation Warning

```
Warning: Shader validation returned status 0: Validation Failed: No vertex array object bound.
```

**å½±éŸ¿**: ç„¡å¯¦éš›å½±éŸ¿ï¼Œåƒ…ç‚º OpenGL é©—è­‰è­¦å‘Š
**ç‹€æ…‹**: å¯å¿½ç•¥ï¼Œæ¸²æŸ“æ­£å¸¸é‹ä½œ

## æ•ˆèƒ½æ¯”è¼ƒ

| é …ç›® | CPU (Numba) | GPU (OpenGL) |
|------|-------------|--------------|
| æ¸²æŸ“æ–¹å¼ | Multi-pass | Single-pass |
| ä¸¦è¡ŒåŒ– | CPU å¤šæ ¸å¿ƒ | GPU ä¸¦è¡Œ |
| Blend ç²¾ç¢ºåº¦ | å®Œå…¨ç²¾ç¢º | å—å–®æ¬¡æ¸²æŸ“é™åˆ¶ |
| æ•´é«”é€Ÿåº¦ | å¿« | éå¸¸å¿« |
| Region map | å®Œç¾æ”¯æ´ | éƒ¨åˆ†æ”¯æ´ |

## å¾ŒçºŒå·¥ä½œå»ºè­°

### é«˜å„ªå…ˆç´š
- ç„¡ï¼ˆæ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½å·²é‹ä½œï¼‰

### ä¸­å„ªå…ˆç´š
- ä¿®å¾© shader validation warningï¼ˆç¾è§€ç”¨é€”ï¼‰
- æ–‡ä»¶åŒ– blend mode åœ¨ region map ä¸‹çš„é™åˆ¶

### ä½å„ªå…ˆç´š
- å¯¦ä½œå¤šæ¬¡æ¸²æŸ“æ¶æ§‹ä»¥æ”¯æ´å®Œæ•´ blend modes with region map
- æ–°å¢æ›´å¤š blend modesï¼ˆå¦‚ Multiply, Overlay ç­‰ï¼‰
- å¯¦ä½œ Ratio (pitch shifting) åŠŸèƒ½
- å¯¦ä½œ Phase (horizontal offset) åŠŸèƒ½

## åƒè€ƒæ–‡ä»¶

- `GPU_REFACTOR_PLAN_20251104.md` - å¤šæ¬¡æ¸²æŸ“æ¶æ§‹è¨­è¨ˆ
- `GPU_MULTIVERSE_BUGFIX_20251104.md` - é›»å£“æ­£è¦åŒ– bug åˆ†æ
- `Multiverse.cpp` - åŸå§‹ VCV Rack æ¨¡çµ„ (lines 286-550)
- `vav/visual/numba_renderer.py` - CPU åƒè€ƒå¯¦ä½œ

## ç‰ˆæœ¬è³‡è¨Š

- **ä¿®å¾©æ—¥æœŸ**: 2025-11-04
- **ç‰ˆæœ¬æ¨™ç±¤**: GPU_REFACTOR_20251104_2318
- **ä¿®å¾©è€…**: Claude Code
- **æ¸¬è©¦ç‹€æ…‹**: âœ“ å·²é©—è­‰æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½
- **Git ç‹€æ…‹**: æº–å‚™æäº¤

## çµè«–

GPU Multiverse æ¸²æŸ“å™¨ç¾å·²å®Œå…¨é‹ä½œï¼Œé›»å£“æ­£è¦åŒ–ã€region mapã€æ—‹è½‰ç¸®æ”¾ç­‰æ ¸å¿ƒåŠŸèƒ½èˆ‡ CPU ç‰ˆæœ¬ä¸€è‡´ã€‚Blend modes åœ¨ç„¡ region map æ™‚å®Œç¾é‹ä½œï¼Œæœ‰ region map æ™‚å—æ¶æ§‹é™åˆ¶ä½†ä»å¯ä½¿ç”¨ã€‚æ•´é«”æ•ˆèƒ½å„ªç•°ï¼Œä½¿ç”¨ Metal backend åœ¨ Apple Silicon ä¸Šé‹è¡Œæµæš¢ã€‚

---

**é‡è¦æ€§**: ğŸ”´ CRITICAL - æ ¸å¿ƒæ¸²æŸ“ä¿®å¾©
**å½±éŸ¿ç¯„åœ**: æ‰€æœ‰ GPU æ¸²æŸ“å™¨è¦–è¦ºè¼¸å‡º
**æ¸¬è©¦ç‹€æ…‹**: âœ“ å®Œå…¨é©—è­‰
**å»ºè­°å‹•ä½œ**: æäº¤è‡³ Git ä¸¦æ¨™è¨˜ç‰ˆæœ¬
