/*
 * Alien4 C++ Extension for Python
 * Complete port of VCV Rack Alien4 module using pybind11
 *
 * Features:
 * - Loop buffer recording (2880000 samples, 60s @ 48kHz)
 * - Slice detection with dynamic threshold
 * - Polyphonic playback (1-8 voices)
 * - 3-band EQ (Low/Mid/High)
 * - Stereo delay with independent L/R times
 * - Reverb with comb/allpass filters
 * - Feedback routing
 */

#include <pybind11/pybind11.h>
#include <pybind11/numpy.h>
#include <pybind11/stl.h>
#include <vector>
#include <cmath>
#include <algorithm>
#include <random>
#include <utility>

namespace py = pybind11;

// Helper functions
template<typename T>
inline T clamp(T value, T min, T max) {
    return std::max(min, std::min(max, value));
}

// ============================================================================
// Slice structure
// ============================================================================
struct Slice {
    int startSample = 0;
    int endSample = 0;
    float peakAmplitude = 0.0f;
    bool active = false;
};

// ============================================================================
// Voice structure for polyphonic playback
// ============================================================================
struct Voice {
    int sliceIndex = 0;
    int playbackPosition = 0;
    float playbackPhase = 0.0f;
    float speedMultiplier = 1.0f;
};

// ============================================================================
// Biquad filter for EQ
// ============================================================================
class BiquadFilter {
public:
    enum Type {
        LOWSHELF,
        PEAK,
        HIGHSHELF
    };

    BiquadFilter() : b0(1.0f), b1(0.0f), b2(0.0f), a1(0.0f), a2(0.0f),
                     z1(0.0f), z2(0.0f) {}

    void setParameters(Type type, float normalizedFreq, float Q, float gain) {
        float w0 = 2.0f * M_PI * normalizedFreq;
        float cosw0 = std::cos(w0);
        float sinw0 = std::sin(w0);
        float alpha = sinw0 / (2.0f * Q);
        float A = gain;

        float a0;

        if (type == LOWSHELF) {
            b0 = A * ((A + 1.0f) - (A - 1.0f) * cosw0 + 2.0f * std::sqrt(A) * alpha);
            b1 = 2.0f * A * ((A - 1.0f) - (A + 1.0f) * cosw0);
            b2 = A * ((A + 1.0f) - (A - 1.0f) * cosw0 - 2.0f * std::sqrt(A) * alpha);
            a0 = (A + 1.0f) + (A - 1.0f) * cosw0 + 2.0f * std::sqrt(A) * alpha;
            a1 = -2.0f * ((A - 1.0f) + (A + 1.0f) * cosw0);
            a2 = (A + 1.0f) + (A - 1.0f) * cosw0 - 2.0f * std::sqrt(A) * alpha;
        } else if (type == PEAK) {
            b0 = 1.0f + alpha * A;
            b1 = -2.0f * cosw0;
            b2 = 1.0f - alpha * A;
            a0 = 1.0f + alpha / A;
            a1 = -2.0f * cosw0;
            a2 = 1.0f - alpha / A;
        } else { // HIGHSHELF
            b0 = A * ((A + 1.0f) + (A - 1.0f) * cosw0 + 2.0f * std::sqrt(A) * alpha);
            b1 = -2.0f * A * ((A - 1.0f) + (A + 1.0f) * cosw0);
            b2 = A * ((A + 1.0f) + (A - 1.0f) * cosw0 - 2.0f * std::sqrt(A) * alpha);
            a0 = (A + 1.0f) - (A - 1.0f) * cosw0 + 2.0f * std::sqrt(A) * alpha;
            a1 = 2.0f * ((A - 1.0f) - (A + 1.0f) * cosw0);
            a2 = (A + 1.0f) - (A - 1.0f) * cosw0 - 2.0f * std::sqrt(A) * alpha;
        }

        // Normalize
        b0 /= a0;
        b1 /= a0;
        b2 /= a0;
        a1 /= a0;
        a2 /= a0;
    }

    float process(float input) {
        float output = b0 * input + z1;
        z1 = b1 * input - a1 * output + z2;
        z2 = b2 * input - a2 * output;
        return output;
    }

    void reset() {
        z1 = z2 = 0.0f;
    }

private:
    float b0, b1, b2, a1, a2;
    float z1, z2;
};

// ============================================================================
// Delay processor
// ============================================================================
class DelayProcessor {
public:
    static constexpr int DELAY_BUFFER_SIZE = 96000;

    DelayProcessor() {
        buffer.resize(DELAY_BUFFER_SIZE, 0.0f);
        writeIndex = 0;
    }

    void reset() {
        std::fill(buffer.begin(), buffer.end(), 0.0f);
        writeIndex = 0;
    }

    float process(float input, float delayTime, float feedback, float sampleRate) {
        int delaySamples = static_cast<int>(delayTime * sampleRate);
        delaySamples = clamp(delaySamples, 1, DELAY_BUFFER_SIZE - 1);

        int readIndex = (writeIndex - delaySamples + DELAY_BUFFER_SIZE) % DELAY_BUFFER_SIZE;
        float delayedSignal = buffer[readIndex];

        buffer[writeIndex] = input + delayedSignal * feedback;
        writeIndex = (writeIndex + 1) % DELAY_BUFFER_SIZE;

        return delayedSignal;
    }

private:
    std::vector<float> buffer;
    int writeIndex;
};

// ============================================================================
// Reverb processor (Freeverb-style with stereo spread)
// ============================================================================
class ReverbProcessor {
public:
    // Base sizes for left channel
    static constexpr int COMB_1_BASE = 1557;
    static constexpr int COMB_2_BASE = 1617;
    static constexpr int COMB_3_BASE = 1491;
    static constexpr int COMB_4_BASE = 1422;
    static constexpr int ALLPASS_1_BASE = 556;
    static constexpr int ALLPASS_2_BASE = 441;

    // Stereo spread offset (adds variation for right channel)
    static constexpr int STEREO_SPREAD = 23;

    ReverbProcessor(bool isRightChannel = false)
        : comb1Size(COMB_1_BASE + (isRightChannel ? STEREO_SPREAD : 0)),
          comb2Size(COMB_2_BASE + (isRightChannel ? STEREO_SPREAD : 0)),
          comb3Size(COMB_3_BASE + (isRightChannel ? STEREO_SPREAD : 0)),
          comb4Size(COMB_4_BASE + (isRightChannel ? STEREO_SPREAD : 0)),
          allpass1Size(ALLPASS_1_BASE + (isRightChannel ? STEREO_SPREAD : 0)),
          allpass2Size(ALLPASS_2_BASE + (isRightChannel ? STEREO_SPREAD : 0))
    {
        combBuffer1.resize(comb1Size, 0.0f);
        combBuffer2.resize(comb2Size, 0.0f);
        combBuffer3.resize(comb3Size, 0.0f);
        combBuffer4.resize(comb4Size, 0.0f);
        allpassBuffer1.resize(allpass1Size, 0.0f);
        allpassBuffer2.resize(allpass2Size, 0.0f);
        reset();
    }

    void reset() {
        std::fill(combBuffer1.begin(), combBuffer1.end(), 0.0f);
        std::fill(combBuffer2.begin(), combBuffer2.end(), 0.0f);
        std::fill(combBuffer3.begin(), combBuffer3.end(), 0.0f);
        std::fill(combBuffer4.begin(), combBuffer4.end(), 0.0f);
        std::fill(allpassBuffer1.begin(), allpassBuffer1.end(), 0.0f);
        std::fill(allpassBuffer2.begin(), allpassBuffer2.end(), 0.0f);

        combIndex1 = combIndex2 = combIndex3 = combIndex4 = 0;
        allpassIndex1 = allpassIndex2 = 0;
        combLp1 = combLp2 = combLp3 = combLp4 = 0.0f;
        hpState = 0.0f;
    }

    float processComb(float input, std::vector<float>& buffer, int size,
                     int& index, float feedback, float& lp, float damping) {
        float output = buffer[index];
        lp = lp + (output - lp) * damping;
        buffer[index] = input + lp * feedback;
        index = (index + 1) % size;
        return output;
    }

    float processAllpass(float input, std::vector<float>& buffer, int size,
                        int& index, float gain) {
        float delayed = buffer[index];
        float output = -input * gain + delayed;
        buffer[index] = input + delayed * gain;
        index = (index + 1) % size;
        return output;
    }

    float process(float input, float roomSize, float damping, float decay, float sampleRate) {
        float feedback = 0.5f + decay * 0.485f;
        float dampingCoeff = 0.05f + damping * 0.9f;
        float roomScale = 0.3f + roomSize * 1.4f;

        float roomInput = input * roomScale;
        float combOut = 0.0f;

        combOut += processComb(roomInput, combBuffer1, comb1Size, combIndex1,
                              feedback, combLp1, dampingCoeff);
        combOut += processComb(roomInput, combBuffer2, comb2Size, combIndex2,
                              feedback, combLp2, dampingCoeff);
        combOut += processComb(roomInput, combBuffer3, comb3Size, combIndex3,
                              feedback, combLp3, dampingCoeff);
        combOut += processComb(roomInput, combBuffer4, comb4Size, combIndex4,
                              feedback, combLp4, dampingCoeff);

        combOut *= 0.25f;

        float diffused = combOut;
        diffused = processAllpass(diffused, allpassBuffer1, allpass1Size,
                                 allpassIndex1, 0.5f);
        diffused = processAllpass(diffused, allpassBuffer2, allpass2Size,
                                 allpassIndex2, 0.5f);

        // Highpass filter
        float hpCutoff = 100.0f / (sampleRate * 0.5f);
        hpCutoff = clamp(hpCutoff, 0.001f, 0.1f);
        hpState += (diffused - hpState) * hpCutoff;
        float hpOutput = diffused - hpState;

        return hpOutput;
    }

private:
    std::vector<float> combBuffer1, combBuffer2, combBuffer3, combBuffer4;
    std::vector<float> allpassBuffer1, allpassBuffer2;
    int combIndex1, combIndex2, combIndex3, combIndex4;
    int allpassIndex1, allpassIndex2;
    float combLp1, combLp2, combLp3, combLp4;
    float hpState;

    // Buffer sizes (different for L/R channels for stereo effect)
    int comb1Size, comb2Size, comb3Size, comb4Size;
    int allpass1Size, allpass2Size;
};

// ============================================================================
// Main AudioEngine class
// ============================================================================
class AudioEngine {
public:
    static constexpr int LOOP_BUFFER_SIZE = 2880000; // 60 seconds at 48kHz

    AudioEngine(double sample_rate)
        : sampleRate(sample_rate),
          loopBuffer(LOOP_BUFFER_SIZE, 0.0f),
          tempBuffer(LOOP_BUFFER_SIZE, 0.0f),
          randomEngine(std::random_device()()),
          reverbL(false),  // Left channel
          reverbR(true)    // Right channel with stereo spread
    {
        // Initialize default parameters
        isRecording = false;
        isLooping = true;

        scanValue = 0.0f;
        minSliceTimeKnob = 0.5f; // Default 0.5 â†’ ~1.0s
        mixValue = 0.0f;
        feedbackValue = 0.0f;
        speedValue = 1.0f;

        eqLowDb = 0.0f;
        eqMidDb = 0.0f;
        eqHighDb = 0.0f;

        delayTimeL = 0.25f;
        delayTimeR = 0.25f;
        delayFeedback = 0.3f;
        delayWet = 0.5f;

        reverbRoom = 1.0f;
        reverbDamping = 1.0f;
        reverbDecay = 0.6f;
        reverbWet = 0.5f;

        numVoices = 1;
        voices.resize(1);

        playbackPosition = 0;
        playbackPhase = 0.0f;
        recordedLength = 0;
        currentSliceIndex = 0;
        lastAmplitude = 0.0f;
        lastMinSliceTime = getMinSliceTime();
        lastScanTargetIndex = -1;
        lastScanValue = -1.0f;

        tempRecordPosition = 0;
        tempRecordedLength = 0;
        tempLastAmplitude = 0.0f;

        lastOutputL = 0.0f;
        lastOutputR = 0.0f;
    }

    // ========================================================================
    // Recording control
    // ========================================================================
    void set_recording(bool enabled) {
        if (enabled == isRecording) return;

        if (enabled) {
            // Start recording
            std::fill(tempBuffer.begin(), tempBuffer.end(), 0.0f);
            tempSlices.clear();
            tempRecordPosition = 0;
            tempRecordedLength = 0;
            tempLastAmplitude = 0.0f;
            isRecording = true;
        } else {
            // Stop recording: finalize
            float minSliceTime = getMinSliceTime();
            int minSliceSamples = static_cast<int>(minSliceTime * sampleRate);

            // Close last slice
            if (!tempSlices.empty() && tempSlices.back().active &&
                tempSlices.back().endSample == 0) {
                int sliceLength = tempRecordedLength - tempSlices.back().startSample;
                if (sliceLength >= minSliceSamples) {
                    tempSlices.back().endSample = tempRecordedLength - 1;
                } else {
                    tempSlices.pop_back();
                }
            }

            // Copy temp to main
            std::copy(tempBuffer.begin(), tempBuffer.end(), loopBuffer.begin());
            slices = tempSlices;
            recordedLength = tempRecordedLength;
            playbackPosition = 0;
            playbackPhase = 0.0f;
            currentSliceIndex = 0;
            lastAmplitude = 0.0f;

            // Reset voices
            for (auto& v : voices) {
                v.sliceIndex = 0;
                v.playbackPosition = 0;
                v.playbackPhase = 0.0f;
                v.speedMultiplier = 1.0f;
            }

            // Redistribute if poly
            if (numVoices > 1) {
                redistributeVoices();
            }

            isRecording = false;
        }
    }

    void set_looping(bool enabled) {
        isLooping = enabled;
    }

    void clear() {
        std::fill(loopBuffer.begin(), loopBuffer.end(), 0.0f);
        std::fill(tempBuffer.begin(), tempBuffer.end(), 0.0f);
        slices.clear();
        tempSlices.clear();
        playbackPosition = 0;
        playbackPhase = 0.0f;
        recordedLength = 0;
        currentSliceIndex = 0;
        lastAmplitude = 0.0f;
        lastScanTargetIndex = -1;
        tempRecordPosition = 0;
        tempRecordedLength = 0;
        tempLastAmplitude = 0.0f;
        lastOutputL = 0.0f;
        lastOutputR = 0.0f;

        delayL.reset();
        delayR.reset();
        reverbL.reset();
        reverbR.reset();

        eqLowL.reset();
        eqLowR.reset();
        eqMidL.reset();
        eqMidR.reset();
        eqHighL.reset();
        eqHighR.reset();
    }

    // ========================================================================
    // Slice control
    // ========================================================================
    void set_scan(double value) {
        scanValue = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    void set_min_slice_time(double value) {
        minSliceTimeKnob = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    void set_poly(int voices_count) {
        int newVoices = clamp(voices_count, 1, 8);
        if (newVoices != numVoices) {
            numVoices = newVoices;
            voices.resize(numVoices);

            if (!slices.empty() && numVoices > 1) {
                // Initialize voice 0 with current playback state
                if (!voices.empty()) {
                    voices[0].sliceIndex = currentSliceIndex;
                    voices[0].playbackPosition = playbackPosition;
                    voices[0].playbackPhase = playbackPhase;
                    voices[0].speedMultiplier = 1.0f;
                }
                // Redistribute other voices to random slices
                redistributeVoices();
            } else {
                // Single voice or no slices: all voices follow current state
                for (auto& v : voices) {
                    v.sliceIndex = currentSliceIndex;
                    v.playbackPosition = playbackPosition;
                    v.playbackPhase = playbackPhase;
                    v.speedMultiplier = 1.0f;
                }
            }
        }
    }

    // ========================================================================
    // Documenta parameters
    // ========================================================================
    void set_mix(double value) {
        mixValue = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    void set_feedback(double value) {
        feedbackValue = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    void set_speed(double value) {
        speedValue = clamp(static_cast<float>(value), -8.0f, 8.0f);
    }

    void set_eq_low(double db) {
        eqLowDb = clamp(static_cast<float>(db), -20.0f, 20.0f);
    }

    void set_eq_mid(double db) {
        eqMidDb = clamp(static_cast<float>(db), -20.0f, 20.0f);
    }

    void set_eq_high(double db) {
        eqHighDb = clamp(static_cast<float>(db), -20.0f, 20.0f);
    }

    // ========================================================================
    // Delay parameters
    // ========================================================================
    void set_delay_time(double time_l, double time_r) {
        delayTimeL = clamp(static_cast<float>(time_l), 0.001f, 2.0f);
        delayTimeR = clamp(static_cast<float>(time_r), 0.001f, 2.0f);
    }

    void set_delay_feedback(double value) {
        delayFeedback = clamp(static_cast<float>(value), 0.0f, 0.95f);
    }

    void set_delay_wet(double value) {
        delayWet = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    // ========================================================================
    // Reverb parameters
    // ========================================================================
    void set_reverb_room(double value) {
        reverbRoom = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    void set_reverb_damping(double value) {
        reverbDamping = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    void set_reverb_decay(double value) {
        reverbDecay = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    void set_reverb_wet(double value) {
        reverbWet = clamp(static_cast<float>(value), 0.0f, 1.0f);
    }

    // ========================================================================
    // Process audio
    // ========================================================================
    std::pair<py::array_t<float>, py::array_t<float>>
    process(py::array_t<float> left_in, py::array_t<float> right_in) {
        auto left_buf = left_in.request();
        auto right_buf = right_in.request();

        if (left_buf.ndim != 1 || right_buf.ndim != 1) {
            throw std::runtime_error("Input arrays must be 1-dimensional");
        }

        size_t num_samples = left_buf.shape[0];
        if (right_buf.shape[0] != static_cast<ssize_t>(num_samples)) {
            throw std::runtime_error("Left and right inputs must have same length");
        }

        float* left_in_ptr = static_cast<float*>(left_buf.ptr);
        float* right_in_ptr = static_cast<float*>(right_buf.ptr);

        // Allocate output
        py::array_t<float> left_out(num_samples);
        py::array_t<float> right_out(num_samples);

        auto left_out_buf = left_out.request();
        auto right_out_buf = right_out.request();

        float* left_out_ptr = static_cast<float*>(left_out_buf.ptr);
        float* right_out_ptr = static_cast<float*>(right_out_buf.ptr);

        // ====================================================================
        // Pre-process: Check parameter changes (once per buffer, not per sample)
        // ====================================================================

        // Check if minSliceTime changed
        float threshold = 0.5f;
        float minSliceTime = getMinSliceTime();

        if (!isRecording && recordedLength > 0 &&
            std::abs(minSliceTime - lastMinSliceTime) > 0.001f) {
            rescanSlices(threshold, minSliceTime);
            // After rescan, ensure voice 0 is still valid
            if (numVoices > 1 && !voices.empty() && !slices.empty()) {
                // Keep voice 0 on a valid slice
                if (currentSliceIndex >= static_cast<int>(slices.size())) {
                    currentSliceIndex = 0;
                }
                voices[0].sliceIndex = currentSliceIndex;
                voices[0].playbackPosition = slices[currentSliceIndex].startSample;
                voices[0].playbackPhase = 0.0f;
            }
            redistributeVoices();
            lastMinSliceTime = minSliceTime;
        }

        // SCAN functionality - check if SCAN value changed
        if (std::abs(scanValue - lastScanValue) > 0.001f) {
            redistributeVoices();
            lastScanValue = scanValue;
        }

        // Apply SCAN parameter to jump to target slice
        if (slices.size() > 1) {
            bool useManualScan = scanValue > 0.01f;

            if (useManualScan) {
                int targetSliceIndex = static_cast<int>(
                    std::round(scanValue * (slices.size() - 1)));
                targetSliceIndex = clamp(targetSliceIndex, 0,
                                       static_cast<int>(slices.size()) - 1);

                if (targetSliceIndex != lastScanTargetIndex &&
                    slices[targetSliceIndex].active) {
                    currentSliceIndex = targetSliceIndex;
                    playbackPosition = slices[targetSliceIndex].startSample;
                    playbackPhase = 0.0f;
                    lastScanTargetIndex = targetSliceIndex;

                    if (numVoices > 1 && !voices.empty()) {
                        voices[0].sliceIndex = targetSliceIndex;
                        voices[0].playbackPosition = slices[targetSliceIndex].startSample;
                        voices[0].playbackPhase = 0.0f;
                    }
                }
            } else {
                lastScanTargetIndex = -1;
            }
        }

        // ====================================================================
        // Process each sample
        // ====================================================================
        for (size_t i = 0; i < num_samples; i++) {
            float input = left_in_ptr[i]; // Mono input

            // Recording
            if (isRecording && tempRecordPosition < LOOP_BUFFER_SIZE) {
                tempBuffer[tempRecordPosition] = input;
                tempRecordedLength = tempRecordPosition + 1;

                float currentAmp = std::abs(input);
                int minSliceSamples = static_cast<int>(minSliceTime * sampleRate);

                if (tempLastAmplitude < threshold && currentAmp >= threshold) {
                    if (!tempSlices.empty() && tempSlices.back().active &&
                        tempSlices.back().endSample == 0) {
                        int sliceLength = tempRecordPosition - tempSlices.back().startSample;
                        if (sliceLength >= minSliceSamples) {
                            tempSlices.back().endSample = tempRecordPosition - 1;
                        } else {
                            tempSlices.pop_back();
                        }
                    }

                    if (tempSlices.empty() || tempSlices.back().endSample > 0) {
                        Slice newSlice;
                        newSlice.startSample = tempRecordPosition;
                        newSlice.active = true;
                        newSlice.peakAmplitude = 0.0f;
                        tempSlices.push_back(newSlice);
                    }
                }

                if (!tempSlices.empty() && tempSlices.back().active &&
                    tempSlices.back().endSample == 0) {
                    tempSlices.back().peakAmplitude = std::max(
                        tempSlices.back().peakAmplitude, currentAmp);
                }

                tempLastAmplitude = currentAmp;
                tempRecordPosition++;
            }

            // Playback
            float loopL = 0.0f;
            float loopR = 0.0f;

            if (recordedLength > 0) {
                bool isReverse = speedValue < 0.0f;

                if (numVoices == 1 || voices.empty()) {
                    // Single voice mode
                    playbackPhase += speedValue;
                    int positionDelta = static_cast<int>(playbackPhase);
                    playbackPhase -= static_cast<float>(positionDelta);
                    playbackPosition += positionDelta;

                    // Loop current slice
                    if (!slices.empty() && currentSliceIndex < static_cast<int>(slices.size())
                        && slices[currentSliceIndex].active) {
                        int sliceStart = slices[currentSliceIndex].startSample;
                        int sliceEnd = slices[currentSliceIndex].endSample;

                        if (isReverse) {
                            if (playbackPosition < sliceStart) {
                                playbackPosition = sliceEnd;
                            }
                        } else {
                            if (playbackPosition > sliceEnd) {
                                playbackPosition = sliceStart;
                            }
                        }
                    } else {
                        // No slices: loop entire buffer
                        if (isReverse) {
                            if (playbackPosition < 0) {
                                playbackPosition = recordedLength - 1;
                            }
                        } else {
                            if (playbackPosition >= recordedLength) {
                                playbackPosition = 0;
                            }
                        }
                    }

                    // Read with interpolation
                    if (recordedLength > 0) {
                        playbackPosition = clamp(playbackPosition, 0, recordedLength - 1);
                        int pos0 = playbackPosition;
                        int pos1 = (recordedLength > 1) ? ((pos0 + 1) % recordedLength) : pos0;

                        pos0 = clamp(pos0, 0, LOOP_BUFFER_SIZE - 1);
                        pos1 = clamp(pos1, 0, LOOP_BUFFER_SIZE - 1);

                        float frac = clamp(std::abs(playbackPhase), 0.0f, 1.0f);

                        float sample = loopBuffer[pos0] * (1.0f - frac) +
                                     loopBuffer[pos1] * frac;
                        loopL = sample;
                        loopR = sample;
                    }
                } else {
                    // Multiple voices mode
                    for (int v = 0; v < numVoices; v++) {
                        float voiceSpeed = speedValue * voices[v].speedMultiplier;
                        voiceSpeed = clamp(voiceSpeed, -16.0f, 16.0f);
                        voices[v].playbackPhase += voiceSpeed;

                        int positionDelta = static_cast<int>(voices[v].playbackPhase);
                        voices[v].playbackPhase -= static_cast<float>(positionDelta);
                        voices[v].playbackPosition += positionDelta;

                        // Loop current slice for each voice
                        if (!slices.empty() && voices[v].sliceIndex < static_cast<int>(slices.size())
                            && slices[voices[v].sliceIndex].active) {
                            int sliceStart = slices[voices[v].sliceIndex].startSample;
                            int sliceEnd = slices[voices[v].sliceIndex].endSample;

                            bool voiceReverse = voiceSpeed < 0.0f;
                            if (voiceReverse) {
                                if (voices[v].playbackPosition < sliceStart) {
                                    voices[v].playbackPosition = sliceEnd;
                                }
                            } else {
                                if (voices[v].playbackPosition > sliceEnd) {
                                    voices[v].playbackPosition = sliceStart;
                                }
                            }
                        } else {
                            // No valid slice: loop entire buffer
                            bool voiceReverse = voiceSpeed < 0.0f;
                            if (voiceReverse) {
                                if (voices[v].playbackPosition < 0) {
                                    voices[v].playbackPosition = recordedLength - 1;
                                }
                            } else {
                                if (voices[v].playbackPosition >= recordedLength) {
                                    voices[v].playbackPosition = 0;
                                }
                            }
                        }

                        // Read with interpolation
                        if (recordedLength > 0) {
                            voices[v].playbackPosition = clamp(voices[v].playbackPosition,
                                                              0, recordedLength - 1);
                            int pos0 = voices[v].playbackPosition;
                            int pos1 = (recordedLength > 1) ? ((pos0 + 1) % recordedLength) : pos0;

                            pos0 = clamp(pos0, 0, LOOP_BUFFER_SIZE - 1);
                            pos1 = clamp(pos1, 0, LOOP_BUFFER_SIZE - 1);

                            float frac = clamp(std::abs(voices[v].playbackPhase), 0.0f, 1.0f);

                            float sample = loopBuffer[pos0] * (1.0f - frac) +
                                         loopBuffer[pos1] * frac;

                            if (std::isfinite(sample)) {
                                // Alternate voices between L and R
                                if (v % 2 == 0) {
                                    loopL += sample;
                                } else {
                                    loopR += sample;
                                }
                            }
                        }
                    }

                    // Normalize by sqrt of voices per channel
                    int leftVoices = (numVoices + 1) / 2;
                    int rightVoices = numVoices / 2;
                    if (leftVoices > 0) loopL /= std::sqrt(static_cast<float>(leftVoices));
                    if (rightVoices > 0) loopR /= std::sqrt(static_cast<float>(rightVoices));

                    // Update layer position to voice 0
                    if (!voices.empty()) {
                        playbackPosition = voices[0].playbackPosition;
                        playbackPhase = voices[0].playbackPhase;
                        currentSliceIndex = voices[0].sliceIndex;
                    }
                }
            }

            // MIX control
            float mixedL = input * (1.0f - mixValue) + loopL * mixValue;
            float mixedR = input * (1.0f - mixValue) + loopR * mixValue;

            // FEEDBACK
            float fbL = std::tanh(lastOutputL * 0.3f) / 0.3f;
            float fbR = std::tanh(lastOutputR * 0.3f) / 0.3f;

            mixedL += fbL * feedbackValue;
            mixedR += fbR * feedbackValue;

            // 3-Band EQ
            float eqLowGain = std::pow(10.0f, eqLowDb / 20.0f);
            float eqMidGain = std::pow(10.0f, eqMidDb / 20.0f);
            float eqHighGain = std::pow(10.0f, eqHighDb / 20.0f);

            eqLowL.setParameters(BiquadFilter::LOWSHELF, 80.0f / sampleRate,
                                0.707f, eqLowGain);
            eqLowR.setParameters(BiquadFilter::LOWSHELF, 80.0f / sampleRate,
                                0.707f, eqLowGain);
            eqMidL.setParameters(BiquadFilter::PEAK, 2500.0f / sampleRate,
                                0.707f, eqMidGain);
            eqMidR.setParameters(BiquadFilter::PEAK, 2500.0f / sampleRate,
                                0.707f, eqMidGain);
            eqHighL.setParameters(BiquadFilter::HIGHSHELF, 12000.0f / sampleRate,
                                 0.707f, eqHighGain);
            eqHighR.setParameters(BiquadFilter::HIGHSHELF, 12000.0f / sampleRate,
                                 0.707f, eqHighGain);

            float eqL = eqLowL.process(mixedL);
            eqL = eqMidL.process(eqL);
            eqL = eqHighL.process(eqL);

            float eqR = eqLowR.process(mixedR);
            eqR = eqMidR.process(eqR);
            eqR = eqHighR.process(eqR);

            // Delay processing - ensure true stereo independence
            // Process left channel delay with left-specific parameters
            float delayedL = delayL.process(eqL, delayTimeL, delayFeedback, sampleRate);

            // Process right channel delay with right-specific parameters
            float delayedR = delayR.process(eqR, delayTimeR, delayFeedback, sampleRate);

            // Mix delayed signals independently for each channel
            float delayMixL = eqL * (1.0f - delayWet) + delayedL * delayWet;
            float delayMixR = eqR * (1.0f - delayWet) + delayedR * delayWet;

            // Reverb processing
            float reverbedL = reverbL.process(delayMixL, reverbRoom, reverbDamping,
                                             reverbDecay, sampleRate);
            float reverbedR = reverbR.process(delayMixR, reverbRoom, reverbDamping,
                                             reverbDecay, sampleRate);

            float outputL = delayMixL * (1.0f - reverbWet) + reverbedL * reverbWet;
            float outputR = delayMixR * (1.0f - reverbWet) + reverbedR * reverbWet;

            // Store for feedback
            lastOutputL = outputL;
            lastOutputR = outputR;

            // Output (clamp to safe range)
            left_out_ptr[i] = clamp(outputL, -10.0f, 10.0f);
            right_out_ptr[i] = clamp(outputR, -10.0f, 10.0f);
        }

        return std::make_pair(left_out, right_out);
    }

private:
    double sampleRate;

    // Loop buffer
    std::vector<float> loopBuffer;
    int playbackPosition;
    float playbackPhase;
    int recordedLength;
    int currentSliceIndex;
    float lastAmplitude;
    float lastMinSliceTime;
    int lastScanTargetIndex;

    // Temp buffer (during recording)
    std::vector<float> tempBuffer;
    std::vector<Slice> tempSlices;
    int tempRecordPosition;
    int tempRecordedLength;
    float tempLastAmplitude;

    // Slices
    std::vector<Slice> slices;

    // Polyphonic voices
    std::vector<Voice> voices;
    int numVoices;
    std::default_random_engine randomEngine;
    float lastScanValue;

    // EQ filters (stereo)
    BiquadFilter eqLowL, eqLowR;
    BiquadFilter eqMidL, eqMidR;
    BiquadFilter eqHighL, eqHighR;

    // Effects processors
    DelayProcessor delayL, delayR;
    ReverbProcessor reverbL, reverbR;

    // State
    bool isRecording;
    bool isLooping;

    // Feedback state
    float lastOutputL;
    float lastOutputR;

    // Parameters
    float scanValue;
    float minSliceTimeKnob;
    float mixValue;
    float feedbackValue;
    float speedValue;
    float eqLowDb, eqMidDb, eqHighDb;
    float delayTimeL, delayTimeR, delayFeedback, delayWet;
    float reverbRoom, reverbDamping, reverbDecay, reverbWet;

    // Convert MIN_SLICE_TIME knob value (0-1) to actual time (0.001-5.0 seconds)
    float getMinSliceTime() {
        if (minSliceTimeKnob <= 0.5f) {
            // Left half: exponential from 0.001 to 1.0
            float t = minSliceTimeKnob * 2.0f;
            return 0.001f * std::pow(1000.0f, t);
        } else {
            // Right half: linear from 1.0 to 5.0
            float t = (minSliceTimeKnob - 0.5f) * 2.0f;
            return 1.0f + t * 4.0f;
        }
    }

    void rescanSlices(float threshold, float minSliceTime) {
        if (recordedLength <= 0) return;

        slices.clear();
        int minSliceSamples = static_cast<int>(minSliceTime * sampleRate);
        float lastAmp = 0.0f;

        for (int pos = 0; pos < recordedLength; pos++) {
            float currentAmp = std::abs(loopBuffer[pos]);

            if (lastAmp < threshold && currentAmp >= threshold) {
                if (!slices.empty() && slices.back().active) {
                    int sliceLength = pos - slices.back().startSample;
                    if (sliceLength >= minSliceSamples) {
                        slices.back().endSample = pos - 1;
                    } else {
                        slices.pop_back();
                    }
                }

                if (slices.empty() || slices.back().endSample > 0) {
                    Slice newSlice;
                    newSlice.startSample = pos;
                    newSlice.active = true;
                    newSlice.peakAmplitude = 0.0f;
                    slices.push_back(newSlice);
                }
            }

            if (!slices.empty() && slices.back().active && slices.back().endSample == 0) {
                slices.back().peakAmplitude = std::max(slices.back().peakAmplitude, currentAmp);
            }

            lastAmp = currentAmp;
        }

        if (!slices.empty() && slices.back().active && slices.back().endSample == 0) {
            int sliceLength = recordedLength - slices.back().startSample;
            if (sliceLength >= minSliceSamples) {
                slices.back().endSample = recordedLength - 1;
            } else {
                slices.pop_back();
            }
        }

        if (currentSliceIndex >= static_cast<int>(slices.size())) {
            currentSliceIndex = slices.empty() ? 0 : static_cast<int>(slices.size()) - 1;
        }
    }

    void redistributeVoices() {
        if (slices.empty() || numVoices <= 1 || voices.empty()) return;

        std::uniform_int_distribution<int> sliceDist(0, slices.size() - 1);
        std::uniform_real_distribution<float> speedDist(-2.0f, 2.0f);

        for (int i = 1; i < numVoices; i++) {
            int targetSliceIndex = sliceDist(randomEngine);
            int attempts = 0;
            while (attempts < 20 && (!slices[targetSliceIndex].active ||
                   slices[targetSliceIndex].startSample >= recordedLength)) {
                targetSliceIndex = sliceDist(randomEngine);
                attempts++;
            }

            if (!slices[targetSliceIndex].active ||
                slices[targetSliceIndex].startSample >= recordedLength) {
                continue;
            }

            voices[i].sliceIndex = targetSliceIndex;
            voices[i].playbackPosition = slices[targetSliceIndex].startSample;
            voices[i].playbackPhase = 0.0f;
            voices[i].speedMultiplier = speedDist(randomEngine);
        }
    }
};

// ============================================================================
// pybind11 bindings
// ============================================================================
PYBIND11_MODULE(alien4, m) {
    m.doc() = "Alien4 Audio Engine - Complete VCV Rack port";

    py::class_<AudioEngine>(m, "AudioEngine")
        .def(py::init<double>(), py::arg("sample_rate") = 48000.0,
             "Create AudioEngine with specified sample rate")

        // Recording control
        .def("set_recording", &AudioEngine::set_recording,
             py::arg("enabled"),
             "Enable/disable recording")
        .def("set_looping", &AudioEngine::set_looping,
             py::arg("enabled"),
             "Enable/disable looping")
        .def("clear", &AudioEngine::clear,
             "Clear all buffers and reset state")

        // Slice control
        .def("set_scan", &AudioEngine::set_scan,
             py::arg("value"),
             "Set slice scan position (0.0-1.0)")
        .def("set_min_slice_time", &AudioEngine::set_min_slice_time,
             py::arg("value"),
             "Set minimum slice time knob (0.0-1.0)")
        .def("set_poly", &AudioEngine::set_poly,
             py::arg("voices"),
             "Set number of polyphonic voices (1-8)")

        // Documenta parameters
        .def("set_mix", &AudioEngine::set_mix,
             py::arg("value"),
             "Set dry/wet mix (0.0-1.0)")
        .def("set_feedback", &AudioEngine::set_feedback,
             py::arg("value"),
             "Set feedback amount (0.0-1.0)")
        .def("set_speed", &AudioEngine::set_speed,
             py::arg("value"),
             "Set playback speed (-8.0 to +8.0)")
        .def("set_eq_low", &AudioEngine::set_eq_low,
             py::arg("db"),
             "Set low EQ gain (-20 to +20 dB)")
        .def("set_eq_mid", &AudioEngine::set_eq_mid,
             py::arg("db"),
             "Set mid EQ gain (-20 to +20 dB)")
        .def("set_eq_high", &AudioEngine::set_eq_high,
             py::arg("db"),
             "Set high EQ gain (-20 to +20 dB)")

        // Delay parameters
        .def("set_delay_time", &AudioEngine::set_delay_time,
             py::arg("time_l"), py::arg("time_r"),
             "Set delay times L/R (0.001-2.0 seconds)")
        .def("set_delay_feedback", &AudioEngine::set_delay_feedback,
             py::arg("value"),
             "Set delay feedback (0.0-0.95)")
        .def("set_delay_wet", &AudioEngine::set_delay_wet,
             py::arg("value"),
             "Set delay wet/dry mix (0.0-1.0)")

        // Reverb parameters
        .def("set_reverb_room", &AudioEngine::set_reverb_room,
             py::arg("value"),
             "Set reverb room size (0.0-1.0)")
        .def("set_reverb_damping", &AudioEngine::set_reverb_damping,
             py::arg("value"),
             "Set reverb damping (0.0-1.0)")
        .def("set_reverb_decay", &AudioEngine::set_reverb_decay,
             py::arg("value"),
             "Set reverb decay (0.0-1.0)")
        .def("set_reverb_wet", &AudioEngine::set_reverb_wet,
             py::arg("value"),
             "Set reverb wet/dry mix (0.0-1.0)")

        // Process audio
        .def("process", &AudioEngine::process,
             py::arg("left_in"), py::arg("right_in"),
             "Process audio buffers. Returns (left_out, right_out)");

    m.attr("__version__") = "1.0.0";
    m.attr("LOOP_BUFFER_SIZE") = AudioEngine::LOOP_BUFFER_SIZE;
}
